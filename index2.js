/*
Требуется реализовать функцию spy которая умеет шпионить за другой функцией.
*/

function spy(f) {
  function wrapper(...args) {
    wrapper.data.calls++;
    wrapper.data.args.push(args);
    const result = f.apply(this, args);
    wrapper.data.results.push(result);
    return result;
  }

  wrapper.data = {
    calls: 0,
    args: [],
    results: []
  };

  return wrapper;
}



// Написать функцию addOne, которая
// при вызове увеличивает счетчик на единицу
// возвращает функцию, при этом эту функцию снова можно вызвать и она вернет функцию
// получить значение счетчика можно вызвав метод getValue

function addOne() {
  let count = 1;

  function inner() {
    count++;
    return inner;
  }

  inner.getValue = function() {
    return count;
  };

  return inner;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++


// Наше приложение-чат должно отображать новые сообщения, которые приходят с сервера, как можно быстрее.
//   Сообщение имеет формат:
//
//   interface Message {
//   id: number
//   text: string
// }
// Id самого первого сообщения = 1, а id каждого следующего сообщения на 1 больше, чем id предыдущего. Нам нужно выводить сообщения в правильном порядке, однако сервер не гарантирует правильный порядок сообщений, отправляемых в наше приложение.
//   Сообщения от сервера приходят в обработчик функции connect:
//
//   connect((msg) => {
//   ...
//   });
// Отображать сообщения нужно с помощью функции render:
//   render(msg)

function solution(connect, render) {
  const latestMessages = {};

  connect((msg) => {
    latestMessages[msg.id] = msg;
    renderMessages();
  });

  function renderMessages() {
    const sortedIds = Object.keys(latestMessages).sort((a, b) => a - b);
    sortedIds.forEach((id) => render(latestMessages[id]));
  }
}


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Написать собственный map через прототип
// Array.prototype.map = function (callback ) {
//   // реализация map
// }

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Предыстория: мы с другом участники клуба похудения. Джон переживает, что в опубликованном списке весов участников он самый толстый.
//   Я решил ему помочь и пределожил ему модифицировать порядок списка.
//   Сделать это я решил при помощи введения нового атрибута у веса - "вес" числа.
//   Задача:
// Например, 99 будет иметь "вес" 18, 100 - 1, поэтому 100 в списке будет перед 99.
// Пример:
//   "56 65 74 100 99 68 86 180 90" - есть такая строка, веса расположены в рандомном порядке.
//   В итоге после применения итоговой функции orderWeight должно получиться следующее:
//   "100 180 90 56 65 74 68 86 99"
// Когда 2 номера имеют одинаковый "вес", мы располагаем их в алфавитном порядке как строки, не как числа.
// 180 будет впереди 90, например. Имеет тот же вес, но при этом в алфавитном порядке 180 идет перед 90
// Все числа в массиве положительные, возможно, что массив пустой.
//   Опишите функцию orderWeight

// function orderWeight() {
// }

// console.log(orderWeight('56 65 74 100 99 68 86 180 90')); // 100 180 90 56 65 74 68 86 99
//
// Небольшое усложнение:
//   Может быть рандомное количество пробелов между числами.
//   Опишите функцию orderWeight
//
// function orderWeight() {
// }

// console.log(orderWeight('56  65 74 100 99  68 86   180  90')); // 100 180 90 56 65 74 68 86 99
// Оригинальная задача - https://www.codewars.com/kata/55c6126177c9441a570000cc

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Дан массив точек с целочисленными координатами (x, y). Определить, существует ли вертикальная прямая, делящая все точки, не лежащие на ней, на 2 симметричных относительно этой прямой набора точек.
//   Наборы симметричны когда каждая точка исходного массива имеет пару из другого набора.
//   Инварианты условия, псевдокодом:
// isVertSym([[0, 0], [0, 1], [1, 1], [2, 2], [3, 1], [4, 1], [4, 0]]) // true
// isVertSym([[0, 0], [0, 0], [1, 1], [2, 2], [3, 1], [4, 0], [4, 0]]) // true
// isVertSym([[0, 0], [0, 0], [1, 1], [2, 2], [3, 1], [4, 0]]) // false
// isVertSym([]) // true
// isVertSym([[0, 0]]) // true
// isVertSym([[0, 0], [10, 0]]) // true
// isVertSym([[0, 0], [11, 1]]) // false
// isVertSym([[0, 0], [1, 0], [3, 0]]) // false


module.exports = {
  spy,
  addOne,
  solution
}
